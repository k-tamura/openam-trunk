<?xml version="1.0" encoding="UTF-8"?>
<!--
    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2011 ForgeRock AS. All Rights Reserved
    Copyright 2011 Cybernetica AS.

    The contents of this file are subject to the terms
    of the Common Development and Distribution License
    (the License). You may not use this file except in
    compliance with the License.

    You can obtain a copy of the License at
    http://forgerock.org/license/CDDLv1.0.html
    See the License for the specific language governing
    permission and limitations under the License.

    When distributing Covered Code, include this CDDL
    Header Notice in each file and include the License file
    at http://forgerock.org/license/CDDLv1.0.html
    If applicable, add the following below the CDDL Header,
    with the fields enclosed by brackets [] replaced by
    your own identifying information:
    "Portions Copyrighted [year] [name of copyright owner]"

-->
<!--
    Portions Copyrighted 2012-2014 ForgeRock AS.
    Portions Copyrighted 2012 Open Source Solution Technology Corporation
    Portions Copyrighted 2013 Nomura Research Institute, Ltd
-->

<!DOCTYPE ServicesConfiguration
        PUBLIC "=//iPlanet//Service Management Services (SMS) 1.0 DTD//EN"
        "jar://com/sun/identity/sm/sms.dtd">

<ServicesConfiguration>
    <Service name="iPlanetAMAuthScriptedDevicePrintService" version="1.0">
        <Schema
                serviceHierarchy="/DSAMEConfig/authentication/iPlanetAMAuthScriptedDevicePrintService"
                i18nFileName="amAuthScriptedDevicePrint"
                revisionNumber="1"
                i18nKey="iplanet-am-auth-scripted-device-print-service-description">

            <Organization>
                <AttributeSchema name="iplanet-am-auth-scripted-auth-level"
                                 type="single"
                                 syntax="number_range" rangeStart="0" rangeEnd="2147483647"
                                 i18nKey="a500">
                    <DefaultValues>
                        <Value>0</Value>
                    </DefaultValues>
                </AttributeSchema>
                <AttributeSchema name="iplanet-am-auth-scripted-script-type"
                                 type="single_choice"
                                 syntax="string"
                                 i18nKey="a101">
                    <ChoiceValues>
                        <ChoiceValue i18nKey="choice1">JavaScript</ChoiceValue>
                        <ChoiceValue i18nKey="choice2">Groovy</ChoiceValue>
                    </ChoiceValues>
                    <DefaultValues>
                        <Value>JavaScript</Value>
                    </DefaultValues>
                </AttributeSchema>
                <AttributeSchema name="iplanet-am-auth-scripted-client-script-enabled"
                                 type="single"
                                 syntax="boolean"
                                 i18nKey="a102">
                    <BooleanValues>
                        <BooleanTrueValue i18nKey="i18nTrue">true</BooleanTrueValue>
                        <BooleanFalseValue i18nKey="i18nFalse">false</BooleanFalseValue>
                    </BooleanValues>
                    <DefaultValues>
                        <Value>true</Value>
                    </DefaultValues>
                </AttributeSchema>
                <AttributeSchema name="iplanet-am-auth-scripted-client-script"
                                 type="single"
                                 syntax="script"
                                 validator="no"
                                 i18nKey="a103">
                    <DefaultValues>
                        <Value></Value>
                    </DefaultValues>
                </AttributeSchema>
                <AttributeSchema name="iplanet-am-auth-scripted-server-script"
                                 type="single"
                                 syntax="script"
                                 validator="ScriptValidator"
                                 i18nKey="a104">
                    <DefaultValues>
                        <Value></Value>
                    </DefaultValues>
                </AttributeSchema>

                <SubSchema name="serverconfig" inheritance="multiple">
                    <AttributeSchema name="ScriptValidator"
                                     type="validator"
                                     syntax="string">
                        <DefaultValues>
                            <Value>org.forgerock.openam.authentication.modules.scripted.ScriptValidator</Value>
                            <Value>com.sun.identity.sm.RequiredValueValidator</Value>
                        </DefaultValues>
                    </AttributeSchema>
                    <AttributeSchema name="iplanet-am-auth-scripted-auth-level"
                                     type="single"
                                     syntax="number_range" rangeStart="0" rangeEnd="2147483647"
                                     i18nKey="a500">
                    <DefaultValues>
                        <Value>1</Value>
                    </DefaultValues>
                    </AttributeSchema>
                    <AttributeSchema name="iplanet-am-auth-scripted-script-type"
                                     type="single_choice"
                                     syntax="string"
                                     i18nKey="a101">
                        <ChoiceValues>
                            <ChoiceValue i18nKey="choice1">JavaScript</ChoiceValue>
                            <ChoiceValue i18nKey="choice2">Groovy</ChoiceValue>
                        </ChoiceValues>
                        <DefaultValues>
                            <Value>JavaScript</Value>
                        </DefaultValues>
                    </AttributeSchema>
                    <AttributeSchema name="iplanet-am-auth-scripted-client-script-enabled"
                                     type="single"
                                     syntax="boolean"
                                     i18nKey="a102">
                        <BooleanValues>
                            <BooleanTrueValue i18nKey="i18nTrue">true</BooleanTrueValue>
                            <BooleanFalseValue i18nKey="i18nFalse">false</BooleanFalseValue>
                        </BooleanValues>
                        <DefaultValues>
                            <Value>true</Value>
                        </DefaultValues>
                    </AttributeSchema>
                    <AttributeSchema name="iplanet-am-auth-scripted-client-script"
                                     type="single"
                                     syntax="script"
                                     validator="no"
                                     i18nKey="a103">
                        <DefaultValues>
                            <Value>
var collectScreenInfo = function () {
        var screenInfo = {};
        if (screen) {
            if (screen.width) {
                screenInfo.screenWidth = screen.width;
            }

            if (screen.height) {
                screenInfo.screenHeight = screen.height;
            }

            if (screen.pixelDepth) {
                screenInfo.screenColourDepth = screen.pixelDepth;
            }
        } else {
            console.warn("Cannot collect screen information. screen is not defined.");
        }
        return screenInfo;
        },
        collectTimezoneInfo = function () {
            var timezoneInfo =  {}, offset = new Date().getTimezoneOffset();

            if (offset) {
                timezoneInfo.timezone = offset;
            } else {
                console.warn("Cannot collect timezone information. timezone is not defined.");
            }

            return timezoneInfo;
        },
        collectBrowserPluginsInfo = function () {

            if (navigator &amp;&amp; navigator.plugins) {
                var pluginsInfo = {}, i, plugins = navigator.plugins;
                pluginsInfo.installedPlugins = "";

                for (i = 0; i &lt; plugins.length; i++) {
                    pluginsInfo.installedPlugins = pluginsInfo.installedPlugins + plugins[i].filename + ";";
                }

                pluginsInfo.installedPlugins = pluginsInfo.installedPlugins.substr(0, pluginsInfo.installedPlugins.length - 1);

                return pluginsInfo;
            } else {
                console.warn("Cannot collect browser plugin information. navigator.plugins is not defined.");
                return {};
            }

        },
        // Getting geolocation takes some time and is done asynchronously, hence need a callback which is called once geolocation is retrieved.
        collectGeolocationInfo = function (callback) {
            var geolocationInfo = {};
            if (navigator &amp;&amp; navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    geolocationInfo.longitude = position.coords.longitude;
                    geolocationInfo.latitude = position.coords.latitude;
                    callback(geolocationInfo);
                });
            } else {
                console.warn("Cannot collect geolocation information. navigator.geolocation is not defined.");
                callback(geolocationInfo);
            }
        },
        fontDetector = (function () {
            /**
             * JavaScript code to detect available availability of a
             * particular font in a browser using JavaScript and CSS.
             *
             * Author : Lalit Patel
             * Website: http://www.lalit.org/lab/javascript-css-font-detect/
             * License: Apache Software License 2.0
             *          http://www.apache.org/licenses/LICENSE-2.0
             * Version: 0.15 (21 Sep 2009)
             *          Changed comparision font to default from sans-default-default,
             *          as in FF3.0 font of child element didn't fallback
             *          to parent element if the font is missing.
             * Version: 0.2 (04 Mar 2012)
             *          Comparing font against all the 3 generic font families ie,
             *          'monospace', 'sans-serif' and 'sans'. If it doesn't match all 3
             *          then that font is 100% not available in the system
             * Version: 0.3 (24 Mar 2012)
             *          Replaced sans with serif in the list of baseFonts
             */
            /*
             * Portions Copyrighted 2013 ForgeRock AS.
             */
            var detector = {}, baseFonts, testString, testSize, h, s, defaultWidth = {}, defaultHeight = {}, index;

            // a font will be compared against all the three default fonts.
            // and if it doesn't match all 3 then that font is not available.
            baseFonts = ['monospace', 'sans-serif', 'serif'];

            //we use m or w because these two characters take up the maximum width.
            // And we use a LLi so that the same matching fonts can get separated
            testString = "mmmmmmmmmmlli";

            //we test using 72px font size, we may use any size. I guess larger the better.
            testSize = '72px';

            h = document.getElementsByTagName("body")[0];

            // create a SPAN in the document to get the width of the text we use to test
            s = document.createElement("span");
            s.style.fontSize = testSize;
            s.innerHTML = testString;
            for (index in baseFonts) {
                //get the default width for the three base fonts
                s.style.fontFamily = baseFonts[index];
                h.appendChild(s);
                defaultWidth[baseFonts[index]] = s.offsetWidth; //width for the default font
                defaultHeight[baseFonts[index]] = s.offsetHeight; //height for the defualt font
                h.removeChild(s);
            }

            detector.detect = function(font) {
                var detected = false, index, matched;
                for (index in baseFonts) {
                    s.style.fontFamily = font + ',' + baseFonts[index]; // name of the font along with the base font for fallback.
                    h.appendChild(s);
                    matched = (s.offsetWidth !== defaultWidth[baseFonts[index]] || s.offsetHeight !== defaultHeight[baseFonts[index]]);
                    h.removeChild(s);
                    detected = detected || matched;
                }
                return detected;
            };

            return detector;
        })(),
        collectBrowserFontsInfo = function () {
            var fontsInfo = {}, i, fontsList = ["cursive","monospace","serif","sans-serif","fantasy","default","Arial","Arial Black",
                "Arial Narrow","Arial Rounded MT Bold","Bookman Old Style","Bradley Hand ITC","Century","Century Gothic",
                "Comic Sans MS","Courier","Courier New","Georgia","Gentium","Impact","King","Lucida Console","Lalit",
                "Modena","Monotype Corsiva","Papyrus","Tahoma","TeX","Times","Times New Roman","Trebuchet MS","Verdana",
                "Verona"];
            fontsInfo.installedFonts = "";

            for (i = 0; i &lt; fontsList.length; i++) {
                if (fontDetector.detect(fontsList[i])) {
                    fontsInfo.installedFonts = fontsInfo.installedFonts + fontsList[i] + ";";
                }
            }
            return fontsInfo;
        },
        devicePrint = {};

devicePrint.screen = collectScreenInfo();
devicePrint.timezone = collectTimezoneInfo();
devicePrint.plugins = collectBrowserPluginsInfo();
devicePrint.fonts = collectBrowserFontsInfo();

if (navigator.userAgent) {
    devicePrint.userAgent = navigator.userAgent;
}
if (navigator.appName) {
    devicePrint.appName = navigator.appName;
}
if (navigator.appCodeName) {
    devicePrint.appCodeName = navigator.appCodeName;
}
if (navigator.appVersion) {
    devicePrint.appVersion = navigator.appVersion;
}
if (navigator.appMinorVersion) {
    devicePrint.appMinorVersion = navigator.appMinorVersion;
}
if (navigator.buildID) {
    devicePrint.buildID = navigator.buildID;
}
if (navigator.platform) {
    devicePrint.platform = navigator.platform;
}
if (navigator.cpuClass) {
    devicePrint.cpuClass = navigator.cpuClass;
}
if (navigator.oscpu) {
    devicePrint.oscpu = navigator.oscpu;
}
if (navigator.product) {
    devicePrint.product = navigator.product;
}
if (navigator.productSub) {
    devicePrint.productSub = navigator.productSub;
}
if (navigator.vendor) {
    devicePrint.vendor = navigator.vendor;
}
if (navigator.vendorSub) {
    devicePrint.vendorSub = navigator.vendorSub;
}
if (navigator.language) {
    devicePrint.language = navigator.language;
}
if (navigator.userLanguage) {
    devicePrint.userLanguage = navigator.userLanguage;
}
if (navigator.browserLanguage) {
    devicePrint.browserLanguage = navigator.browserLanguage;
}
if (navigator.systemLanguage) {
    devicePrint.systemLanguage = navigator.systemLanguage;
}

// This will cause the script to wait until the user's location has been found.
// To avoid the wait move the output.value assignment outside of the function callback
collectGeolocationInfo(function(geolocationInfo) {
    devicePrint.geolocation = geolocationInfo;
    output.value = JSON.stringify(devicePrint);
});
                            </Value>
                        </DefaultValues>
                    </AttributeSchema>
                    <AttributeSchema name="iplanet-am-auth-scripted-server-script"
                                     type="single"
                                     syntax="script"
                                     validator="ScriptValidator"
                                     i18nKey="a104">
                        <DefaultValues>
                            <Value>
var ScalarComparator = {}, ScreenComparator = {}, MultiValueComparator = {}, UserAgentComparator = {}, GeolocationComparator = {}, DEBUG = logger;

var config = {
    profileExpiration: 30,              //in days
    maxProfilesAllowed: 5,
    maxPenaltyPoints: 200,
    attributes: {
        screen: {
            required: true,
            comparator: ScreenComparator,
            args: {
                penaltyPoints: 50
            }
        },
        plugins: {
            installedPlugins: {
                required: false,
                comparator: MultiValueComparator,
                args: {
                    maxPercentageDifference: 10,
                    maxDifferences: 5,
                    penaltyPoints: 100
                }
            }
        },
        fonts: {
            installedFonts: {
                required: false,
                comparator: MultiValueComparator,
                args: {
                    penaltyPoints: 100
                }
            }
        },
        timezone: {
            timezone: {
                required: false,
                comparator: ScalarComparator,
                args: {
                    penaltyPoints: 100
                }
            }
        },
        userAgent: {
            required: true,
            comparator: UserAgentComparator,
            args: {
                ignoreVersion: true,
                penaltyPoints: 100
            }
        },
        geolocation: {
            required: false,
            comparator: GeolocationComparator,
            args: {
                allowedRange: 100,          //in miles
                penaltyPoints: 100
            }
        }
    }
};

//---------------------------------------------------------------------------//
//                           Comparator functions                            //
//---------------------------------------------------------------------------//

var all, any, calculateDistance, calculateIntersection, calculatePercentage, splitAndTrim;

/**
 * Compares two simple objects (String|Number) and if they are equal then returns a ComparisonResult with zero
 * penalty points assigned, otherwise returns a ComparisonResult with the given number of penalty points assigned.
 *
 * @param currentValue (String|Number) The current value.
 * @param storedValue (String|Number) The stored value.
 * @param config: {
 *            "penaltyPoints": (Number) The number of penalty points.
 *        }
 * @return ComparisonResult.
 */
ScalarComparator.compare = function (currentValue, storedValue, config) {
    if (DEBUG.messageEnabled()) {
        DEBUG.message("StringComparator.compare:currentValue: " + JSON.stringify(currentValue));
        DEBUG.message("StringComparator.compare:storedValue: " + JSON.stringify(storedValue));
        DEBUG.message("StringComparator.compare:config: " + JSON.stringify(config));
    }
    if (config.penaltyPoints === 0) {
        return ComparisonResult.ZERO_PENALTY_POINTS;
    }

    if (storedValue !== null) {
        if (currentValue === null || currentValue !== storedValue) {
            return new ComparisonResult(config.penaltyPoints);
        }
    } else if (currentValue !== null) {
        return new ComparisonResult(true);
    }

    return ComparisonResult.ZERO_PENALTY_POINTS;
};

/**
 * Compares two screens and if they are equal then returns a ComparisonResult with zero penalty points assigned,
 * otherwise returns a ComparisonResult with the given number of penalty points assigned.
 *
 * @param currentValue: {
 *            "screenWidth": (Number) The current client screen width.
 *            "screenHeight": (Number) The current client screen height.
 *            "screenColourDepth": (Number) The current client screen colour depth.
 *        }
 * @param storedValue: {
 *            "screenWidth": (Number) The stored client screen width.
 *            "screenHeight": (Number) The stored client screen height.
 *            "screenColourDepth": (Number) The stored client screen colour depth.
 *        }
 * @param config: {
 *            "penaltyPoints": (Number) The number of penalty points.
 *        }
 * @return ComparisonResult
 */
ScreenComparator.compare = function (currentValue, storedValue, config) {
    if (DEBUG.messageEnabled()) {
        DEBUG.message("ScreenComparator.compare:currentValue: " + JSON.stringify(currentValue));
        DEBUG.message("ScreenComparator.compare:storedValue: " + JSON.stringify(storedValue));
        DEBUG.message("ScreenComparator.compare:config: " + JSON.stringify(config));
    }

    // if comparing against old profile
    if (storedValue === undefined) {
        return new ComparisonResult(config.penaltyPoints);
    }

    var comparisonResults = [
        ScalarComparator.compare(currentValue.screenWidth, storedValue.screenWidth, config),
        ScalarComparator.compare(currentValue.screenHeight, storedValue.screenHeight, config),
        ScalarComparator.compare(currentValue.screenColourDepth, storedValue.screenColourDepth, config)];

    if (all(comparisonResults, ComparisonResult.isSuccessful)) {
        return new ComparisonResult(any(comparisonResults, ComparisonResult.additionalInfoInCurrentValue));
    } else {
        return new ComparisonResult(config.penaltyPoints);
    }
};

/**
 * Splits both values using delimiter, trims every value and compares collections of values.
 * Returns zero-result for same multi-value attributes.
 *
 * If collections are not same checks if number of differences is less or equal maxDifferences or
 * percentage of difference is less or equal maxPercentageDifference.
 *
 * If yes then returns zero-result with additional info, else returns penaltyPoints-result.
 *
 * @param currentValue: (String) The current value.
 * @param storedValue: (String) The stored value.
 * @param config: {
 *            "maxPercentageDifference": (Number) The max difference percentage in the values,
 *                                                before the penalty is assigned.
 *            "maxDifferences": (Number) The max number of differences in the values,
 *                                       before the penalty points are assigned.
 *            "penaltyPoints": (Number) The number of penalty points.
  *        }
 * @return ComparisonResult
 */
MultiValueComparator.compare = function (currentValue, storedValue, config) {
    if (DEBUG.messageEnabled()) {
        DEBUG.message("MultiValueComparator.compare:currentValue: " + JSON.stringify(currentValue));
        DEBUG.message("MultiValueComparator.compare:storedValue: " + JSON.stringify(storedValue));
        DEBUG.message("MultiValueComparator.compare:config: " + JSON.stringify(config));
    }

    var delimiter = ";";
    var currentValues = splitAndTrim(currentValue, delimiter);
    var storedValues = splitAndTrim(storedValue, delimiter);

    if (storedValue === null &amp;&amp; currentValue !== null &amp;&amp; currentValues.length === 0) {
        return new ComparisonResult(true);
    }

    var maxNumberOfElements = Math.max(currentValues.length, storedValues.length);
    var numberOfTheSameElements = calculateIntersection(currentValues, storedValues).length;
    var numberOfDifferences = maxNumberOfElements - numberOfTheSameElements;
    var percentageOfDifferences = calculatePercentage(numberOfDifferences, maxNumberOfElements);

    if (DEBUG.messageEnabled()) {
        DEBUG.message(numberOfTheSameElements + " of " + maxNumberOfElements + " are same");
    }

    if (maxNumberOfElements === 0) {
        DEBUG.message("Ignored because no attributes found in both profiles");
        return ComparisonResult.ZERO_PENALTY_POINTS;
    }

    if (numberOfTheSameElements === maxNumberOfElements) {
        DEBUG.message("Ignored because all attributes are same");
        return ComparisonResult.ZERO_PENALTY_POINTS;
    }

    if (numberOfDifferences > config.maxDifferences) {
        if (DEBUG.messageEnabled()) {
            DEBUG.message("Would be ignored if not more than " + config.maxDifferences + " differences");
        }
        return new ComparisonResult(config.penaltyPoints);
    }

    if (percentageOfDifferences > config.maxPercentageDifference) {
        if (DEBUG.messageEnabled()) {
            DEBUG.message(percentageOfDifferences + " percents are different");
            DEBUG.message("Would be ignored if not more than " + config.maxPercentageDifference + " percent");
        }
        return new ComparisonResult(config.penaltyPoints);
    }

     if (DEBUG.messageEnabled()) {
         DEBUG.message("Ignored because number of differences(" + numberOfDifferences + ") not more than "
                 + config.maxDifferences);
         DEBUG.message(percentageOfDifferences + " percents are different");
         DEBUG.message("Ignored because not more than " + config.maxPercentageDifference + " percent");
     }
    return new ComparisonResult(true);
};

/**
 * Compares two User Agent Strings and if they are equal then returns a ComparisonResult with zero penalty
 * points assigned, otherwise returns a ComparisonResult with the given number of penalty points assigned.
 *
 * @param currentValue (String) The current value.
 * @param storedValue (String) The stored value.
 * @param config: {
 *            "ignoreVersion": (boolean) If the version numbers in the User Agent Strings should be ignore
 *                                       in the comparison.
 *            "penaltyPoints": (Number) The number of penalty points.
 *        }
 * @return A ComparisonResult.
 */
UserAgentComparator.compare = function (currentValue, storedValue, config) {
    if (DEBUG.messageEnabled()) {
        DEBUG.message("UserAgentComparator.compare:currentValue: " + JSON.stringify(currentValue));
        DEBUG.message("UserAgentComparator.compare:storedValue: " + JSON.stringify(storedValue));
        DEBUG.message("UserAgentComparator.compare:config: " + JSON.stringify(config));
    }

    if (config.ignoreVersion) {
        // remove version number
        currentValue = currentValue.replace(/[\d\.]+/g, "").trim();
        storedValue = storedValue.replace(/[\d\.]+/g, "").trim();
    }

    return ScalarComparator.compare(currentValue, storedValue, config);
};

/**
 * Compares two locations, taking into account a degree of difference.
 *
 * @param currentValue: {
 *            "latitude": (Number) The current latitude.
 *            "longitude": (Number) The current longitude.
 *        }
 * @param storedValue: {
 *            "latitude": (Number) The stored latitude.
 *            "longitude": (Number) The stored longitude.
 *        }
 * @param config: {
 *            "allowedRange": (Number) The max difference allowed in the two locations, before the penalty is assigned.
 *            "penaltyPoints": (Number) The number of penalty points.
*         }
 * @return ComparisonResult
 */
GeolocationComparator.compare = function (currentValue, storedValue, config) {
    if (DEBUG.messageEnabled()) {
        DEBUG.message("GeolocationComparator.compare:currentValue: " + JSON.stringify(currentValue));
        DEBUG.message("GeolocationComparator.compare:storedValue: " + JSON.stringify(storedValue));
        DEBUG.message("GeolocationComparator.compare:config: " + JSON.stringify(config));
    }

    // if comparing against old profile
    if (storedValue === undefined) {
        return new ComparisonResult(config.penaltyPoints);
    }

    // both null
    if ((currentValue.latitude === null || currentValue.longitude === null)
        &amp;&amp; (storedValue.latitude === null || storedValue.longitude === null)) {
        return ComparisonResult.ZERO_PENALTY_POINTS;
    }

    // current null, stored not null
    if ((currentValue.latitude === null || currentValue.longitude === null)
        &amp;&amp; (storedValue.latitude !== null &amp;&amp; storedValue.longitude !== null)) {
        return new ComparisonResult(config.penaltyPoints);
    }

    // current not null, stored null
    if ((currentValue.latitude !== null &amp;&amp; currentValue.longitude !== null)
        &amp;&amp; (storedValue.latitude === null || storedValue.longitude === null)) {
        return new ComparisonResult(config.penaltyPoints, true);
    }

    // both have values, therefore perform comparison
    var distance = calculateDistance(currentValue, storedValue);

    if (DEBUG.messageEnabled()) {
        DEBUG.message("Distance between (" + currentValue.latitude + "," + currentValue.longitude + ") and (" +
            storedValue.latitude + "," + storedValue.longitude + ") is " + distance + " miles");
    }

    if (parseFloat(distance.toPrecision(5)) === 0) {
        DEBUG.message("Location is the same");
        return ComparisonResult.ZERO_PENALTY_POINTS;
    }

    if (distance &lt;= config.allowedRange) {
        if (DEBUG.messageEnabled()) {
            DEBUG.message("Tolerated because distance not more then " + config.allowedRange);
        }
        return new ComparisonResult(true);
    } else {
        if (DEBUG.messageEnabled()) {
            DEBUG.message("Would be ignored if distance not more then " + config.allowedRange);
        }
        return new ComparisonResult(config.penaltyPoints);
    }
};


//---------------------------------------------------------------------------//
//                    Device Print Logic - DO NOT MODIFY                     //
//---------------------------------------------------------------------------//

// Utility functions

/**
 * Returns true if evaluating function f on each element of the Array a returns true.
 *
 * @param a: (Array) The array of elements to evaluate
 * @param f: (Function) A single argument function for mapping elements of the array to boolean.
 * @return boolean.
 */
all = function(a, f) {
    for (var i = 0; i &lt; a.length; i++) {
        if (f(a[i]) === false) {
            return false;
        }
    }
    return true;
}

/**
 * Returns true if evaluating function f on any element of the Array a returns true.
 *
 * @param a: (Array) The array of elements to evaluate
 * @param f: (Function) A single argument function for mapping elements of the array to boolean.
 * @return boolean.
 */
any = function(a, f) {
    for (var i = 0; i &lt; a.length; i++) {
        if (f(a[i]) === true) {
            return true;
        }
    }
    return false;
}

/**
 * Calculates the distances between the two locations.
 *
 * @param first: {
 *            "latitude": (Number) The first latitude.
 *            "longitude": (Number) The first longitude.
 *        }
 * @param second: {
 *            "latitude": (Number) The second latitude.
 *            "longitude": (Number) The second longitude.
 *        }
 * @return Number The distance between the two locations.
 */
calculateDistance = function(first, second) {
    var factor = (Math.PI / 180);
    function degreesToRadians(degrees) {
        return degrees * factor;
    }
    function radiansToDegrees(radians) {
        return radians / factor;
    }
    var theta = first.longitude - second.longitude;
    var dist = Math.sin(degreesToRadians(first.latitude)) * Math.sin(degreesToRadians(second.latitude))
        + Math.cos(degreesToRadians(first.latitude)) * Math.cos(degreesToRadians(second.latitude))
        * Math.cos(degreesToRadians(theta));
    dist = Math.acos(dist);
    dist = radiansToDegrees(dist);
    dist = dist * 60 * 1.1515;
    return dist;
};

/**
 * Converts a String holding a delimited sequence of values into an array.
 *
 * @param text (String) The String representation of a delimited sequence of values.
 * @param delimiter (String) The character delimiting values within the text String.
 * @return (Array) The comma separated values.
 */
splitAndTrim = function(text, delimiter) {

    var results = [];
    if (text === null) {
        return results;
    }

    var values = text.split(delimiter);
    for (var i = 0; i &lt; values.length; i++) {
        var value = values[i].trim();
        if (value !== "") {
            results.push(value);
        }
    }

    return results;
};

/**
 * Converts value to a percentage of range.
 *
 * @param value (Number) The actual number to be converted to a percentage.
 * @param range (Number) The total number of values (i.e. represents 100%).
 * @return (Number) The percentage.
 */
calculatePercentage = function(value, range) {
    if (range === 0) {
        return 0;
    }
    return parseFloat((value / range).toPrecision(2)) * 100;
};

/**
 * Creates a new array containing only those elements found in both arrays received as arguments.
 *
 * @param first (Array) The first array.
 * @param second (Array) The second array.
 * @return (Array) The elements that found in first and second.
 */
calculateIntersection = function(first, second) {
    return first.filter(function(element) {
        return second.indexOf(element) !== -1;
    });
};

// ComparisonResult

/**
 * Constructs an instance of a ComparisonResult with the given penalty points.
 *
 * @param penaltyPoints (Number) The penalty points for the comparison (defaults to 0).
 * @param additionalInfoInCurrentValue (boolean) Whether the current value contains more information
 *                                               than the stored value (defaults to false).
 */
function ComparisonResult() {

    var penaltyPoints = 0;
    var additionalInfoInCurrentValue = false;

    if (arguments[0] !== undefined &amp;&amp; arguments[1] !== undefined) {
        penaltyPoints = arguments[0];
        additionalInfoInCurrentValue = arguments[1];
    }

    if (arguments[0] !== undefined &amp;&amp; arguments[1] === undefined) {
        if (typeof(arguments[0]) == "boolean") {
            additionalInfoInCurrentValue = arguments[0];
        } else {
            penaltyPoints = arguments[0];
        }
    }

    this.penaltyPoints = penaltyPoints;
    this.additionalInfoInCurrentValue = additionalInfoInCurrentValue;

}

ComparisonResult.ZERO_PENALTY_POINTS = new ComparisonResult(0);

/**
 * Static method for functional programming.
 *
 * @return boolean true if comparisonResult.isSuccessful().
 */
ComparisonResult.isSuccessful =  function(comparisonResult) {
    return comparisonResult.isSuccessful();
};


/**
 * Static method for functional programming.
 *
 * @return boolean true if comparisonResult.additionalInfoInCurrentValue.
 */
ComparisonResult.additionalInfoInCurrentValue =  function(comparisonResult) {
    return comparisonResult.additionalInfoInCurrentValue;
};

/**
 * Comparison function that can be provided as an argument to array.sort
 */
ComparisonResult.compare = function(first, second) {
    if (first === null &amp;&amp; second === null) {
        return 0;
    } else if (first === null) {
        return -1;
    } else if (second === null) {
        return 1;
    } else {
        if (first.penaltyPoints !== second.penaltyPoints) {
            return first.penaltyPoints - second.penaltyPoints;
        } else {
            return (first.additionalInfoInCurrentValue ? 1 : 0) - (second.additionalInfoInCurrentValue ? 1 : 0);
        }
    }
};

/**
 * Amalgamates the given ComparisonResult into this ComparisonResult.
 *
 * @param comparisonResult The ComparisonResult to include.
 */
ComparisonResult.prototype.addComparisonResult = function(comparisonResult) {
    this.penaltyPoints += comparisonResult.penaltyPoints;
    if (comparisonResult.additionalInfoInCurrentValue) {
        this.additionalInfoInCurrentValue = comparisonResult.additionalInfoInCurrentValue;
    }
};

/**
 * Returns true if no penalty points have been assigned for the comparison.
 *
 * @return boolean true if the comparison was successful.
 */
ComparisonResult.prototype.isSuccessful = function() {
    return this.penaltyPoints === null || this.penaltyPoints === 0;
};

function matchDevicePrint() {

    if (!username) {
        DEBUG.error("Username not set. Cannot compare user's device print profiles.");
        authState = FAILED;
    } else {

        var getProfiles = function () {

            function isExpiredProfile(devicePrintProfile) {
                var expirationDate = new Date();
                expirationDate.setDate(expirationDate.getDate() - config.profileExpiration);

                var lastSelectedDate = new Date(devicePrintProfile.lastSelectedDate);

                return lastSelectedDate &lt; expirationDate;
            }

            function getNotExpiredProfiles() {
                var results = [];

                var profiles = idRepository.getAttribute(username, "devicePrintProfiles"),
                    iter = profiles.iterator(),
                    profile;
                while (iter.hasNext()) {
                    profile = JSON.parse(iter.next());
                    if (!isExpiredProfile(profile)) {
                        results.push(profile);
                    }
                }
                if (DEBUG.messageEnabled()) {
                    DEBUG.message("stored non-expired profiles: " + JSON.stringify(results));
                }
                return results;
            }

            return getNotExpiredProfiles();
        };

        if (DEBUG.messageEnabled()) {
            DEBUG.message("client devicePrint: " + clientSideScriptOutput);
        }
        var devicePrint = JSON.parse(clientSideScriptOutput);
        var devicePrintProfiles = getProfiles();


        function getValue(obj, attributePath) {
            var parts = attributePath.split('.'),
                value = obj;
            for (var i = 0; i &lt; parts.length; i++) {
                if (value === undefined) {
                    return null;
                }
                value = value[parts[i]];
            }
            return value;
        }

        function getDevicePrintAttributePaths(devicePrint, attributeConfig) {


            function b(devicePrint, devicePrintProfiles, attributeConfig, attributePath) {

                var attributePaths = [];

                for (var attributeName in attributeConfig) {
                    if (attributeConfig.hasOwnProperty(attributeName)) {
                        var tmp = a(devicePrint, devicePrintProfiles, attributeConfig[attributeName], attributePath + attributeName);
                        attributePaths.push(tmp);
                    }
                }

                return attributePaths;
            }

            function a(devicePrint, devicePrintProfiles, attributeConfig, attributePath) {
                if (attributeConfig.comparator !== undefined) {
                    return attributePath;

                } else {
                    return b(devicePrint, devicePrintProfiles, attributeConfig, attributePath + ".");
                }
            }

            return b(devicePrint, null, attributeConfig, "");
        }

        function hasRequiredAttributes(devicePrint, attributeConfig) {

            var attributePaths = getDevicePrintAttributePaths(devicePrint, attributeConfig);

            for (var i = 0; i &lt; attributePaths.length; i++) {

                var attrValue = getValue(devicePrint, attributePaths[i] + "");
                var attrConfig = getValue(attributeConfig, attributePaths[i] + "");

                if (attrConfig.required &amp;&amp; attrValue === undefined) {
                    DEBUG.warning("Device Print profile missing required attribute, " + attributePaths[i]);
                    return false;
                }
            }

            DEBUG.message("device print has required attributes");
            return true;
        }

        function compareDevicePrintProfiles(attributeConfig, devicePrint, devicePrintProfiles, maxPenaltyPoints) {

            var attributePaths = getDevicePrintAttributePaths(devicePrint, attributeConfig);

            var results = [];
            for (var j = 0; j &lt; devicePrintProfiles.length; j++) {

                var aggregatedComparisonResult = new ComparisonResult();
                for (var i = 0; i &lt; attributePaths.length; i++) {

                    var currentValue = getValue(devicePrint, attributePaths[i] + "");
                    var storedValue = getValue(devicePrintProfiles[j].devicePrint, attributePaths[i] + "");
                    var attrConfig = getValue(attributeConfig, attributePaths[i] + "");

                    var comparisonResult;
                    if (storedValue === null) {
                        comparisonResult = new ComparisonResult(attrConfig.penaltyPoints);
                    } else {
                        comparisonResult = attrConfig.comparator.compare(currentValue, storedValue, attrConfig.args);
                    }

                    if (DEBUG.messageEnabled()) {
                        DEBUG.message("Comparing attribute path: " + attributePaths[i]
                            + ", Comparison result: successful=" + comparisonResult.isSuccessful() + ", penaltyPoints="
                            + comparisonResult.penaltyPoints + ", additionalInfoInCurrentValue="
                            + comparisonResult.additionalInfoInCurrentValue);
                    }
                    aggregatedComparisonResult.addComparisonResult(comparisonResult);
                }
                if (DEBUG.messageEnabled()) {
                    DEBUG.message("Aggregated comparison result: successful="
                        + aggregatedComparisonResult.isSuccessful() + ", penaltyPoints="
                        + aggregatedComparisonResult.penaltyPoints + ", additionalInfoInCurrentValue="
                        + aggregatedComparisonResult.additionalInfoInCurrentValue);
                }

                results.push({
                    key: aggregatedComparisonResult,
                    value: devicePrintProfiles[j]
                });
            }

            if (results.length === 0) {
                return null;
            }

            var selectedComparisonResult = results[0].key;
            if (DEBUG.messageEnabled()) {
                DEBUG.message("Selected comparison result: successful=" + selectedComparisonResult.isSuccessful()
                    + ", penaltyPoints=" + selectedComparisonResult.penaltyPoints + ", additionalInfoInCurrentValue="
                    + selectedComparisonResult.additionalInfoInCurrentValue);
            }

            var selectedProfile = null;
            if (selectedComparisonResult.penaltyPoints &lt;= maxPenaltyPoints) {
                selectedProfile = results[0].value;
                if (DEBUG.messageEnabled()) {
                    DEBUG.message("Selected profile: " + JSON.stringify(selectedProfile));
                }
            }

            if (selectedProfile === null) {
                return false;
            }

            /* update profile */
            selectedProfile.selectionCounter = selectedProfile.selectionCounter + 1;
            selectedProfile.lastSelectedDate = new Date().toISOString();
            selectedProfile.devicePrint = devicePrint;

            var vals = [];
            for (var i = 0; i &lt; devicePrintProfiles.length; i++) {
                vals.push(JSON.stringify(devicePrintProfiles[i]));
            }

            idRepository.setAttribute(username, "devicePrintProfiles", vals);

            return true;
        }

        if (!hasRequiredAttributes(devicePrint, config.attributes)) {
            DEBUG.message("devicePrint.hasRequiredAttributes: false");
            // Will fail this module but fall-through to next module. Which should be OTP.
            authState = FAILED;
        } else if (compareDevicePrintProfiles(config.attributes, devicePrint, devicePrintProfiles, config.maxPenaltyPoints)) {
            DEBUG.message("devicePrint.hasValidProfile: true");
            authState = SUCCESS;
        } else {
            DEBUG.message("devicePrint.hasValidProfile: false");
            sharedState.put('devicePrintProfile', JSON.stringify(devicePrint));
            // Will fail this module but fall-through to next module. Which should be OTP.
            authState = FAILED;
        }
    }
}

matchDevicePrint();
                            </Value>
                        </DefaultValues>
                    </AttributeSchema>

                    <AttributeSchema name="iplanet-am-auth-scripted-auth-level"
                                     type="single"
                                     syntax="number_range" rangeStart="0" rangeEnd="2147483647"
                                     i18nKey="a500">
                        <DefaultValues>
                            <Value>0</Value>
                        </DefaultValues>
                    </AttributeSchema>
                </SubSchema>
            </Organization>
        </Schema>
    </Service>
</ServicesConfiguration>

